The Irresponsible Clojure Guild presents...

# post-grey squirrel

Next-generation SQL generation for postgresql. So next generation that
we need a clojure 1.9 alpha for spec. Sorry about that!

We aim to be able to generate 100% of postgres sql, and we're
prioritising commonly required things. Yes, you can generate json ops
and all the other modern stuff.

Yes, we're designed to be suitable for building libraries on. We were
actually built to support a datalog->postgresql transpiler.

It is currently a non-aim to support other sql dialects. Sorry, but
turns out that supporting one engine with anything like full support
is hard enough.

## Features

* Model queries as clojure data
* Wide language support. We are trying to support almost everything
* Generate SQL ahead of time, without needing data
* Named placeholders - fill query templates with a map
* Preload placeholders - fill out some fields ahead of time so you
  don't have to keep track of them later.
* Regular, easy to understand DSL
* Suitable for library generation

## Status: Alpha

This is my third attempt to write this library, having finally found a
way of doing it that I'm satisfied with. It's still under active
development and it's possible that i'll change how it works soon.

We currently implement "select" only, but we should have 100% coverage
of that part of language (except subqueries that aren't selects!)

## Usage

<!-- Add the dependency to your project.clj or build.boot: -->
<!-- ```clojure -->
<!-- [irresponsible/postgrey.squirrel "0.0.1"] -->
<!-- ``` -->

```clojure
(ns test.pg
 (:require [postgrey.squirrel :as pg :refer [squirrel]]))

(def select-q
  (squirrel {:select/distinct [:f.* :bar.baz
                               ['query {:select [['+ :cnt 1]]
							            :from [:quux]
	                                    :where ['not ['any (? :exclude-ids)]]}]]
	         :from  [['join :left {:f :foo} {:b :bar} ['= :f/id :b/id]]]
             :where ['= :f/id (? :foo-id)]}))

(println (:sql select-q))
(println (:placeholders select-q))
(println (:prefilled sql select-q))


```

## Naming

Some people called PostgreSQL "Post-grey" and some people call SQL "squirrel"
(or at least I do anyway because it's more amusing than "sequel").

Yes, I named my project after a really bad pun. This is not my first time...

Yes, you should start calling SQL "squirrel", because why not?

## Why?

### Because sql and clojure really shouldn't be so painful

Until I discovered [mpg](https://github.com/mpg-project/mpg/) it
really hadn't occurred to me that using a sql database in clojure
could be anything but extreme pain. That module (which back then had
an even stupider name) inspired me to write a few other things to
minimise the pain points associated with SQL databases (for example,
[utrecht](https://github.com/irresponsible/utrecht/) provides a clean
and consistent API over jdbc (which is one of the most horrible APIs I
have ever had the misfortune to work with).

Existing solutions do not make me happy. Here are a few recurring themes:

* Hacks, like generating question marks for IN clauses.
* Writing SQL. Often in external files, sometimes with magic comments.
* Being tied to particular technologies I find deficient
* Poor support for being autogenerated
* Requires bound data at sql generation time
* Cannot neatly generate all the syntax I require (like json operators)

### Because there is more to life than activerecord

Databases are a much more versatile tool than most libraries give them
credit for. They are amazing at reducing data that doesn't map cleanly
to objects as well. Activerecord is a useful pattern for certain types
of applications, but we desire to support the full power of the db by
writing this library at one level lower in the stack.

### Writing SQL does and doesn't suck

I have no real problem with writing sql apart from the point where it
interacts with my clojure. You're then left to choose between
embedding enormous string literals in your file and putting them in an
external file where they can be more easily forgotten about.

This library is not an attempt to avoid thinking in SQL, it's just an
attempt to lift it out of strings into the realm of clojure data.

## FAQ

1. Why do you hate sql-as-strings so much?
     Because it is error prone. The usual fix is to move it into separate
	 files which in my experience induces bit rot.
2. Why do you want to generate SQL ahead of time so much?
     Because I don't like my CPUs to burn cycles doing unnecessary work.
3. Doesn't that cause loads of limitations?
     Not really. It means replacing IN() with ANY() and passing in an array
	 (or a vector if you're using mpg). Unless the basic structure of your
	 query is changing dynamically, you shouldn't have problems
4. Is the input structure programmatically manipulable?
     Yes and no. It's just data, but sometimes the data can be quite complex.
	 If you want to join to new tables and add their fields it shouldn't be
	 too difficult to manipulate programmatically, but this is a library for
	 safely generating sql and not an ORM or any such thing.
5. Named placeholders?
     Yes. When you want to insert a placeholder in the query string, you can
	 provide a placeholder object created by `(? :name)`. When you want to
	 run the query, you pass in a map with the names as keys and the values
	 will be bound to the placeholders.
6. I don't like the syntax!
     It's not final. Please file an issue with your suggestion
7. Why is the code batshit insane?
     Why is SQL batshit insane? This is my third attempt. Help welcome!
8. It generated teh invalid squirrels!
     Generated SQL that fails to compile (and isn't using literal!) is a bug.
	 Please report the bug so we can fix it :)

## Postgresql support


## Usage / Walkthrough

```clojure
(ns my.ns
 (:require [postgrey.squirrel :as pg :refer [?]]))

(def q {:select :distinct
        :fields [:*]
        :from [:join :left
               {:t1 :table1} {:t2 :table2}
               [:= :t1/id :t2/table2_id]]
        :on [:= :t1/id (? :t1-id)]})
(def q2 (pg/compile q))
(def results (pg/query my-db-connectin q2 {:t1-id 12345}))
```

Don't worry, we'll walk through this step by step.

### Basics

Queries take the form of maps with special keywords as keys. Each key has its
own rules for what is valid, which is our modification of the postgres spec

We'll introduce new concepts as we walk through each piece

### Select

There are three forms of the select key which are valid

`:all` - an 'ordinary' select, do not deduplicate rows
`:distinct` - deduplicate rows
`[:distinct-on & exprs]` - distinct only on certain expressions (usually column names)

We'll cover exprs gradually as we go alone

Our example uses `{:select :distinct}`, equivalent to sql `select distinct`

Examples:

```clojure
{:select :distinct
 :fields [:*] :from [:t1]
{:select :all
 :fields [123]}
{:select [:distinct-on :*]
 :fields [:*] :from [:t1]}
```

## Fields

:fields simply takes a vector of expressions, which we avoided explaining in the previous section.

An expression can be the following things:

* boolean/int/log - themselves
* keyword - interpreted as an identifier
* vector 

In the specific case of :fields, an expression can also be a map, which allows you to alias one identifier as another, for example

## Non-postgres support

If you keep to a subset of the syntax, you can probably generate sql that your choice of database can understand. If you're generating it from libraries, you'll want to have a good look at what they generate.

Quite frankly, experience has taught us that SQL database compatibility is a myth at best and that even if it were to exist, you almost certainly should've just used postgres. For this reason we do not explicitly support other databases.

## Status: alpha

It's been very humbling reading the postgres manual and seeing how
many forms of 'select' query there are that i didn't even know
existed. Correctly generating such a complex language is hard and this
module has not existed for long enough for me to have the confidence
that we cover every case.

Please be prepared to report bugs. The only way we will get to
production quality is if brave people like you try me out and report bugs.

## Future

### cljs support

cljs support is planned, but please bear in mind the security implications of generating sql in the browser and then executing it on the server side. cljs support is actually intended for those people daft enough to deploy webservices on node.

## Copyright and License

Copyright (c) 2016 James Laver

MIT LICENSE

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
