 The Irresponsible Clojure Guild presents...

# post-grey squirrel

Next-generation SQL generation for postgresql

## Why?

### Because sql and clojure really shouldn't be so painful

Until I discovered [mpg](https://github.com/mpg-project/mpg/) it
really hadn't occurred to me that using a sql database in clojure
could be anything but extreme pain. That module (which back then had
an even stupider name) inspired me to write a few other things to
minimise the pain points associated with SQL databases (for example,
[utrecht](https://github.com/irresponsible/utrecht/) provides a clean
and consistent API over jdbc (which is one of the most horrible APIs I
have ever had the misfortune to work with).

Existing solutions do not make me happy. Here are a few recurring themes:

* Writing SQL. Often in external files with magic comments.
* Being tied to particular technologies I don't like
* Poor support for being autogenerated
* Requires bound data at sql generation time
* Cannot generate all the syntax I require (like json operators)

### Because there is more to life than activerecord

Databases are a much more versatile tool than most libraries give them
credit for. They are amazing at reducing data that doesn't map cleanly
to objects as well. Activerecord is a useful pattern for certain types
of applications, but we desire to support the full power of the db by
writing this library at one level lower in the stack.

### Writing SQL does and doesn't suck

I have no real problem with writing sql apart from the point where it
interacts with my clojure. You're then left to choose between
embedding enormous string literals in your file and putting them in an
external file where they can be more easily forgotten about.

This library is not an attempt to avoid thinking in SQL, it's just an
attempt to lift it out of strings into the realm of clojure data.

## Features

* Model queries as clojure data
* Support for as much of the sql language as we can see being useful
* Generate queries once, ahead of time and pass in data later
* Named placeholders - fill query templates with a map
* Preload placeholders - fill out some fields ahead of time so you
  don't have to keep track of them later
* With very few (documented and intuitive) exceptions, there is only
  one configuration to generate a particular query

## Postgresql support

Here's postgresql's select synopsis. Things we do not support are surrounded in <>
If it is not inside <>, we support it. There are a few special cases noted underneath.

```
<[ WITH [ RECURSIVE ] with_query [, ...] ]>[1]
SELECT [ ALL | DISTINCT [ ON ( expression [, ...] ) ] ]
[ * | expression [ [ AS ] output_name ] [, ...] ]
[ FROM from_item [, ...] ]
[ WHERE condition ]
[ GROUP BY grouping_element [, ...] ]
[ HAVING condition [, ...] ]
<[ WINDOW window_name AS ( window_definition ) [, ...] ]>[2]
<[ { UNION | INTERSECT | EXCEPT } [ ALL | DISTINCT ] select ]>[3]
[ ORDER BY expression [ ASC | DESC | USING operator ] [ NULLS { FIRST | LAST } ] [, ...] ]
[ LIMIT { count | ALL } ]
[ OFFSET start [ ROW | ROWS ] ]
<[ FETCH { FIRST | NEXT } [ count ] { ROW | ROWS } ONLY ]>[4]
[ FOR { UPDATE | NO KEY UPDATE | SHARE | KEY SHARE } [ OF table_name [, ...] ] [ NOWAIT | SKIP LOCKED ] [...] ]

where from_item can be one of:

[ ONLY ] table_name [ * ] [ [ AS ] alias <[ ( column_alias [, ...] ) ] >[5]]
    <[ TABLESAMPLE sampling_method ( argument [, ...] ) [ REPEATABLE ( seed ) ] ]>[7]
<[ LATERAL ]>[8] ( select ) [ AS ] alias [ ( column_alias [, ...] ) ]>[5]
<with_query_name [ [ AS ] alias [ ( column_alias [, ...] ) ] ]>[8]

<[ LATERAL ]>[8] function_name ( [ argument [, ...] ] )
    <[ WITH ORDINALITY ]>[9] [ [ AS ] alias <[ ( column_alias [, ...] ) ] ]>[5]
<[ LATERAL ]>[8] function_name ( [ argument [, ...] ] ) [ AS ] alias <( column_definition [, ...] )>[10]
<[ LATERAL ]>[8] <function_name ( [ argument [, ...] ] ) AS ( column_definition [, ...] )>[10]
<[ LATERAL ] <ROWS FROM( function_name ( [ argument [, ...] ] ) <[ AS ( column_definition [, ...] ) ] [, ...] )>[10]
    <[ WITH ORDINALITY ]>[9] [ [ AS ] alias <[ ( column_alias [, ...] ) ] ]>[5]
from_item [ NATURAL ] join_type from_item [ ON join_condition | USING ( join_column [, ...] ) ]

and grouping_element can be one of:

( )
expression
( expression [, ...] )
ROLLUP ( { expression | ( expression [, ...] ) } [, ...] )
CUBE ( { expression | ( expression [, ...] ) } [, ...] )
GROUPING SETS ( grouping_element [, ...] )

and with_query is:

<with_query_name [ ( column_name [, ...] ) ] AS ( select | values | insert | update | delete )>[8]

TABLE [ ONLY ] table_name <[ * ]>[15]
```

Notes:
1  With statements are TODO
2  Window functions are TODO. We don't properly understand them.
3  Union/Intersect/Except are coming soon
4  We don't support this because Limit/Offset are better
5  Tablesample is TODO. It's a very expensive operation
6  Column Aliases are coming soon
7  LATERAL support is coming soon
8  WITH queries are coming soon
9  I have no idea what WITH ORDINALITY does, ergo it's low priority
10 
11
12
13
14
15

## Usage / Walkthrough

```clojure
(ns my.ns
 (:require [postgrey.squirrel :as pg :refer [?]]))

(def q {:select :distinct
        :fields [:*]
        :from [:join :left
               {:t1 :table1} {:t2 :table2}
               [:= :t1/id :t2/table2_id]]
        :on [:= :t1/id (? :t1-id)]})
(def q2 (pg/compile q))
(def results (pg/query my-db-connectin q2 {:t1-id 12345}))
```

Don't worry, we'll walk through this step by step.

### Basics

Queries take the form of maps with special keywords as keys. Each key has its
own rules for what is valid, which is our modification of the postgres spec

We'll introduce new concepts as we walk through each piece

### Select

There are three forms of the select key which are valid

`:all` - an 'ordinary' select, do not deduplicate rows
`:distinct` - deduplicate rows
`[:distinct-on & exprs]` - distinct only on certain expressions (usually column names)

We'll cover exprs gradually as we go alone

Our example uses `{:select :distinct}`, equivalent to sql `select distinct`

Examples:

```clojure
{:select :distinct
 :fields [:*] :from [:t1]
{:select :all
 :fields [123]}
{:select [:distinct-on :*]
 :fields [:*] :from [:t1]}
```

## Fields

:fields simply takes a vector of expressions, which we avoided explaining in the previous section.

An expression can be the following things:

* boolean/int/log - themselves
* keyword - interpreted as an identifier
* vector 

In the specific case of :fields, an expression can also be a map, which allows you to alias one identifier as another, for example

## Non-postgres support

If you keep to a subset of the syntax, you can probably generate sql that your choice of database can understand. If you're generating it from libraries, you'll want to have a good look at what they generate.

Quite frankly, experience has taught us that SQL database compatibility is a myth at best and that even if it were to exist, you almost certainly should've just used postgres. For this reason we do not explicitly support other databases.

## Status: alpha

It's been very humbling reading the postgres manual and seeing how
many forms of 'select' query there are that i didn't even know
existed. Correctly generating such a complex language is hard and this
module has not existed for long enough for me to have the confidence
that we cover every case.

Please be prepared to report bugs. The only way we will get to
production quality is if brave people like you try me out and report bugs.

## Future

### cljs support

cljs support is planned, but please bear in mind the security implications of generating sql in the browser and then executing it on the server side. cljs support is actually intended for those people daft enough to deploy webservices on node.

## Copyright and License

Copyright (c) 2016 James Laver

MIT LICENSE

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
